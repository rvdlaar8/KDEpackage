% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fishing2.R
\name{count_group_constraints_fast}
\alias{count_group_constraints_fast}
\title{Count records under group-wise constancy and tolerance constraints}
\usage{
count_group_constraints_fast(dt, k_v, c_v = NULL, n_v = NULL, p)
}
\arguments{
\item{dt}{A \code{data.table}. Will be coerced to \code{data.table} by
reference if it is a plain \code{data.frame}.}

\item{k_v}{Character scalar; name of the grouping column in \code{dt}.}

\item{c_v}{Character vector of column names in \code{dt} to be checked
under the “constant + no NA per group” rule. May be \code{NULL} or
length 0, in which case no counts are produced for \code{c_v}.}

\item{n_v}{Character vector of column names in \code{dt} to be checked
under the “strictly positive + within ±p% + no NA per group” rule.
May be \code{NULL} or length 0, in which case no counts are produced
for \code{n_v}.}

\item{p}{Numeric scalar in \code{[0, 1)}; the relative band as a fraction.
For example, \code{p = 0.01} corresponds to a ±1\% band.}
}
\value{
An integer named vector of length \code{length(c_v) + length(n_v)}.

\itemize{
  \item The first \code{length(c_v)} elements correspond to \code{c_v},
    in the same order, and contain the total number of records whose groups
    satisfy the constancy + no-NA condition for that column.
  \item The last \code{length(n_v)} elements correspond to \code{n_v}, in
    the same order. For each column that globally violates the
    \code{> 0} assumption (i.e. has at least one non-missing value
    \code{<= 0}), the result is \code{NA_integer_}. For the remaining
    columns, the value is the total number of records whose groups satisfy
    the positivity + no-NA + relative-band condition.
}

If both \code{c_v} and \code{n_v} are \code{NULL} or length 0, the function
returns an empty integer vector.
}
\description{
Given a [data.table][data.table::data.table] \code{dt} and a grouping variable
\code{k_v}, this function counts, for each column in \code{c_v}, how many
records belong to groups where that column is constant and contains no
missing values; and for each column in \code{n_v}, how many records belong
to groups where that column is strictly positive, contains no missing
values, and all values within the group fall within a relative band of
\code{±p} around each other.
}
\details{
More precisely:
\itemize{
  \item For each \code{c} in \code{c_v}, a group (defined by \code{k_v})
  contributes \code{.N} rows to the total for that column if:
  \itemize{
    \item \code{anyNA(c) == FALSE} within the group, and
    \item \code{uniqueN(c) == 1} within the group (i.e. constant).
  }

  \item For each \code{n} in \code{n_v}, the column is first checked
  globally: if there exists any non-missing value \code{<= 0}, the output
  for that column is \code{NA_integer_} and no group-wise calculation is
  performed.

  Otherwise (all non-missing values > 0), a group contributes \code{.N}
  rows to the total for that column if:
  \itemize{
    \item the column has no \code{NA} within that group, and
    \item letting \code{mn = min(x)}, \code{mx = max(x)} in the group,
      the relative spread satisfies
      \code{mx <= (1 + p) * mn}.
  }
  If either condition fails, that group contributes 0 for that column.
}

Columns listed in \code{c_v} and \code{n_v} may overlap; they are treated
independently under their respective rules.
}
\examples{
library(data.table)

dt <- data.table(
  g  = c("A","A","A","B","B","B","C","C"),
  c1 = c(1, 1, 1,   2, 2, NA,   3, 3),
  n1 = c(100, 100.5, 99.8,  50, 60, 55,  10, NA),
  n2 = c(10, 10.05, 9.95,  20, 20.1, 19.9,  5, 5.3)
)

# Count constraints per group g:
count_group_constraints_fast(
  dt   = dt,
  k_v  = "g",
  c_v  = "c1",
  n_v  = c("n1", "n2"),
  p    = 0.01
)

}
