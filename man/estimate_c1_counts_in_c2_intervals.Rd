% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/var3_cx.R
\name{estimate_c1_counts_in_c2_intervals}
\alias{estimate_c1_counts_in_c2_intervals}
\title{Schat aantal c_cl-waarden rond c per groep}
\usage{
estimate_c1_counts_in_c2_intervals(
  dt2,
  kol_a,
  kol_c,
  kol_a_cl,
  kol_c_cl,
  ag_a,
  kol_N,
  m,
  auto_bw = TRUE,
  row_limit,
  nomatch = 0L,
  ...verbose,
  show_progress = F,
  logfile,
  timing = F
)
}
\arguments{
\item{dt2}{Een data.table met kolommen kol_a, kol_c, kol_a_cl, kol_c_cl}

\item{kol_a}{Naam van kolom met groeps-id}

\item{kol_c}{Naam van target kolom waarvoor schattingen worden gemaakt}

\item{kol_a_cl}{Naam van kolom met geclusterde groep (voor densities)}

\item{kol_c_cl}{Naam van kolom waarop KDE wordt gebaseerd per cluster}

\item{ag_a}{Een data.table met totalen per groep (kol_a en kol_N)}

\item{kol_N}{Naam van kolom in ag_a met aantal observaties per groep}

\item{m}{Margeparameter (bv. 0.2 betekent +/- 20% rond target)}

\item{auto_bw}{Logisch; TRUE activeert automatische detectie van scherpe densitydalen}

\item{...verbose}{Toon voortgangsinformatie}

\item{timing}{Toon tijdsmetingen}
}
\value{
Een data.table met toegevoegde kolommen lower, upper, estimated_n_cx, method
}
\description{
Voor elke waarde van kol_c in dt2 waarvoor kol_a == kol_a_cl (geclusterde groep),
schat deze functie hoeveel c_cl-waarden binnen het multiplicatieve interval rond kol_c vallen.
}
\details{
De functie gebruikt per clusterwaarde een kernel density estimate (KDE) van kol_c_cl,
tenzij het aantal density-waarnemingen (N2) groter is dan het opgegeven totaal (N1),
in welk geval een exacte telling wordt gebruikt. Er wordt automatisch gecontroleerd
op scherpe densitydalen (indien auto_bw = TRUE), en dan wordt een bredere bandbreedte toegepast.
}
\examples{
library(data.table)
# Voorbeelddata
dt2 <- data.table(
  a = c("g1", "g1", "g2", "g2", "g3"),
  c = c(10, 12, 20, 21, 30),
  a_cl = c("g1", "g1", "g2", "g2", "g3"),
  c_cl = c(11, 13, 19, 22, 30)
)

ag_a <- data.table(a = c("g1", "g2", "g3"), N_group = c(10L, 20L, 5L))

Roep functie aan
resultaat <- estimate_b1_counts_in_c2_intervals(
  dt2 = dt2,
  kol_a = "a",
  kol_c = "c",
  kol_a_cl = "a_cl",
  kol_c_cl = "c_cl",
  ag_a = ag_a,
  kol_N = "N_group",
  m = 0.1,
  auto_bw = TRUE,
  ...verbose = FALSE,
  timing = FALSE
)

head(resultaat)

}
